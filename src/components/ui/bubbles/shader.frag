export default "#define GLSLIFY 1\nuniform sampler2D envMap;\nuniform sampler2D backfaceMap;\nuniform sampler2D u_texture;\nuniform vec2 resolution;\nuniform float u_opacity;\nuniform vec3 u_edgeColor;\nuniform float u_edgeSize;\nuniform float u_edgeOpacity;\nuniform float u_textureOpacity;\nvarying vec3 worldNormal;\n// varying vec3 viewDirection;\n// varying vec2 v_uv;\nvarying vec2 v_uvn;\n\nfloat circle(in vec2 _st, in float _radius, in float blurriness){\n  vec2 dist = _st;\n  return 1.-smoothstep(_radius-(_radius*blurriness), _radius+(_radius*blurriness), dot(dist,dist)*4.0);\n}\n\n// decides the gradient along the edge (high value => sharp edge. low => smooth gradient)\nfloat fresnelFunc(vec3 viewDirection, vec3 worldNormal) {\n  // return pow(1.05 + dot(viewDirection, worldNormal), 100.0);\n\n  // thin edge\n  // return pow( 1.0 + dot( viewDirection, worldNormal), 3.0 );\n\n  return pow( 1.0 + dot( viewDirection, worldNormal), u_edgeSize );\n\n  // flat gradient\n  // return pow( 1.0 + dot( viewDirection, worldNormal), 1.4 );\n  // return pow( 1.0 + dot( viewDirection, worldNormal), 1. );\n}\n\nvec4 blur(vec2 vUv) {\n  float h = 1. / (resolution.x * 1.0);\n  float v = 1. / (resolution.y * 1.0);\n\n  vec4 sum = vec4( 0.0 );\n\n  // hor + vert blur\n  sum += texture2D( envMap, vec2( vUv.x - 4.0 * h, vUv.y - 4.0 * v ) ) * 0.051;\n  sum += texture2D( envMap, vec2( vUv.x - 3.0 * h, vUv.y - 3.0 * v ) ) * 0.0918;\n  sum += texture2D( envMap, vec2( vUv.x - 2.0 * h, vUv.y - 2.0 * v ) ) * 0.12245;\n  sum += texture2D( envMap, vec2( vUv.x - 1.0 * h, vUv.y - 1.0 * v ) ) * 0.1531;\n  sum += texture2D( envMap, vec2( vUv.x, vUv.y ) ) * 0.1633;\n  sum += texture2D( envMap, vec2( vUv.x + 1.0 * h, vUv.y + 1.0 * v ) ) * 0.1531;\n  sum += texture2D( envMap, vec2( vUv.x + 2.0 * h, vUv.y + 2.0 * v ) ) * 0.12245;\n  sum += texture2D( envMap, vec2( vUv.x + 3.0 * h, vUv.y + 3.0 * v ) ) * 0.0918;\n  sum += texture2D( envMap, vec2( vUv.x + 4.0 * h, vUv.y + 4.0 * v ) ) * 0.051;\n\n  return sum;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution ;\n  // vec2 uv = v_uv;\n  //vec3 normal = worldNormal * (1.0 - 0.7) - texture2D(backfaceMap, uv).rgb * 0.7;\n  vec3 normal = worldNormal;\n  // uv += refract(viewDirection, normal, 1.0/1.33).xy;\n  // uv += refract(viewDirection, normal, 1.0/1.03).xy;\n\n  vec2 passUV = uv * 0.99;\n\n  // pass straight through (no anlge on refraction)\n  // uv += refract(vec3(0., 0., -1.), normal, 1.0/1.005).xy; // zoom (ALINE LIKES)\n  uv += refract(vec3(0., 0., -1.), normal, 1.0/1.006).xy; // inverse (flip around 1.05)\n  // uv += refract(vec3(0., 0., -1.), normal, 1.0/1.33).xy; // inverse (flip around 1.05)\n\n  vec4 imageColor = texture2D(envMap, uv);\n  // vec4 imageColorOffset = texture2D(envMap, passUV);\n\n  vec2 textureUv = v_uvn;\n  textureUv.y = 1. - textureUv.y;\n  //textureUv = textureUv * .85 + 0.5 * 0.15;\n  vec4 textureColor = texture2D(u_texture, textureUv);\n\n  // gl_FragColor = vec4(mix(imageColor.rgb, vec3(0.15), fresnelFunc(viewDirection, normal)), 1.0);\n  // gl_FragColor = vec4(mix(blur(uv).rgb*0.5, vec3(.25), fresnelFunc(viewDirection, normal)), .95);\n  // gl_FragColor = vec4(blur(uv).rgb*0.5, 1.0);\n\n  float edge = fresnelFunc(vec3(0., 0., -1.), normal); // same for all\n  // float edge = fresnelFunc(viewDirection, normal); // angled light\n\n  // without blur\n  // vec3 edgeColor = mix(imageColor.rgb*0.33, vec3(.4), edge);\n\n  // with blur\n  vec4 blurImg = blur(uv);\n  // vec3 edgeColor = vec3(.33, .36, .38) * 1.33;\n  vec4 edgeColor = vec4(u_edgeColor, u_edgeOpacity);\n  // vec3 edgeColor = vec3(1.0 - imageColor.r, 1.0 - imageColor.g, 1.0 - imageColor.b) * 0.1;\n  vec3 bubbleColor = mix(vec3(blurImg.r*.95, blurImg.g*.95, blurImg.b), edgeColor.rgb, edge * edgeColor.a);\n\n  vec3 finalColor = mix(bubbleColor, imageColor.rgb, .5);\n  // gl_FragColor = vec4(finalColor, 1.0);\n\n vec2 uv2 = (2.0 * v_uvn - 1.0);   // -1.0 .. 1.0\n  float c = circle(uv2, 3.8, 0.2); // this size is only approx. not good on small bubbles\n  #if __VERSION__ == 300\n    float delta = fwidth(c) * 1.14;\n    float alpha = smoothstep(.5, .5 + delta, c);\n    // float alpha = smoothstep(.8 - delta, .8, c); //small bubble looks better but edge is less visible\n  #else\n    float alpha = smoothstep(0.5, 0.55, c);\n  #endif\n\n  // Alpha blend of textures https://www.khronos.org/opengl/wiki/Multitexture_with_GLSL\n  gl_FragColor =  vec4(mix(textureColor.rgb, bubbleColor.rgb, 1. - textureColor.a * u_textureOpacity), u_opacity * alpha);\n}\n";