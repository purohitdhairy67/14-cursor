export default "#define GLSLIFY 1\nfloat exponentialIn(float t) {\n  return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\n}\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nfloat quadraticInOut(float t) {\n  float p = 2.0 * t * t;\n  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n\nfloat linear(float t) {\n  return t;\n}\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float PI_2 = 1.57079632679489661923;\nconst float PI_4 = 0.785398163397448309616;\n\n// Linear map of input values to output values\n// For instance: [0., 0.5, 1.] -> [10., 100., 10.]\nfloat mix3 (vec3 inputRange, vec3 outputRange, float val) {\n  float value = mix(outputRange.x, outputRange.y, smoothstep(inputRange.x, inputRange.y, val));\n  value = mix(value, outputRange.z, smoothstep(inputRange.y, inputRange.z, val));\n  return value;\n}\n\n// Linear map of input values to output values\n// For instance: [0., 0.5, 0.9, 1.] -> [10., 100., 100., 10.]\nfloat mix4 (vec4 inputRange, vec4 outputRange, float val) {\n  float value = mix(outputRange.x, outputRange.y, smoothstep(inputRange.x, inputRange.y, val));\n  value = mix(value, outputRange.z, smoothstep(inputRange.y, inputRange.z, val));\n  value = mix(value, outputRange.w, smoothstep(inputRange.z, inputRange.w, val));\n  return value;\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat circle(in vec2 _st, in float _radius, in float blurriness){\n  vec2 dist = _st;\n  return 1.-smoothstep(_radius-(_radius*blurriness), _radius+(_radius*blurriness), dot(dist,dist)*4.0);\n}\n\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n// with four individual corner sizes\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nuniform vec3 u_color;\nuniform float u_pixelRatio;\nuniform float u_time;\nuniform vec2 u_res;\nuniform vec2 u_mouse;\nuniform float u_insideLab;\nuniform float u_tabNoiseSpeed;\nuniform sampler2D u_texture;\n\nuniform float u_tab;\nuniform float u_corner;\nuniform float u_frame;\nuniform float u_footer;\n\nvarying vec2 v_uv;\nvarying float v_n;\nvarying float v_tabNoise;\n\nvoid main() {\n\n    vec2 res = u_res * u_pixelRatio;\n    float ratio = u_res.y / u_res.x;\n\n    // get resolution independant size\n    float width = u_res.x / 110.; // 110px makes the png cover a circle with radius 80px in the corner\n    float offset = width * 0.003; // offset tiny bit to hide blur edges on texture\n\n    // sample image color\n    float offsetX = mix(1.0, offset * ratio, u_tab);\n    float offsetY = mix(1.0, offset, u_tab);\n    vec2 uvZoom = v_uv * width - vec2(width - 1.0 + offsetX, -offsetY); // zoom out texture to correct size\n    uvZoom.y *= ratio;\n\n    // read image data\n    vec4 image = texture2D(u_texture, uvZoom);\n\n    // FRAME SIZE\n    float frameRatio = mix(1.0, ratio, 0.33); // not fully square\n    vec2 size = vec2(1.0);\n         size = mix(size, vec2(0.6 * frameRatio, 0.6), smoothstep(0., 0.5, u_frame));\n         size = mix(size, vec2(0.), smoothstep(0.5, 1.0, u_frame));\n\n    // frame radius\n    float radius = mix(0.0, size.x, smoothstep(0.0, 0.3, u_frame));\n\n    // corner radius\n    float radiusCorner = 0.0;\n          // larger corner at footer\n          radiusCorner = mix(radiusCorner, .4, smoothstep(0.0, 1.0, u_footer));\n          // big corner when getting close\n          radiusCorner = mix(radiusCorner, .8, smoothstep(0.0, 1.0, u_corner));\n          // always hide corner if tab is hidden\n          radiusCorner = mix(0.0, radiusCorner, smoothstep(0.0, 1.0, u_tab));\n          // also keep big corner when frame is active\n          radiusCorner = mix(radiusCorner, .8, smoothstep(0.0, 0.14, u_frame));\n          radiusCorner = mix(radiusCorner, radius, smoothstep(0.14, 0.3, u_frame));\n\n     // UV for the rounded box\n    vec2 frameUv = (2.0 * v_uv - 1.0); // -1.0 .. 1.0\n    float frameYOffset = mix(0.0, 0.4, u_footer);\n          frameYOffset = mix(frameYOffset, 0.0, smoothstep(0.0, 0.5, u_frame));\n    float frameXOffset = mix(0.0, 0.09, u_footer);\n          frameXOffset = mix(frameXOffset, 0.0, smoothstep(0.0, 0.5, u_frame));\n    frameUv.y -= frameYOffset;\n    frameUv.x += frameXOffset;\n    float frameMask = sdRoundBox(frameUv, size, vec4(radius, radiusCorner, radius, radius) );\n\n    float frameGoo = 0.25;\n          frameGoo = mix(frameGoo, 0.25, smoothstep(0.0, 1.0, u_footer));\n          frameGoo = mix(frameGoo, 0.0, smoothstep(0.8, 1.0, u_frame));\n\n    frameMask = smoothstep(0., frameGoo, frameMask );\n\n    float nFrame = v_n - 1.; // MUCH FASTER to do noise in vertex shader instead\n    float nTab = v_tabNoise - 1.; // MUCH FASTER to do noise in vertex shader instead\n\n     // ANTIALIAS MASK\n    float finalMask = 0.;\n    float cornerNoise = nTab * clamp(u_tabNoiseSpeed, 0., 1.);//mix(0., nTab, smoothstep(0.0, 1.0, u_corner));\n    float noise = mix(cornerNoise, nFrame, smoothstep(0.0, 0.2, u_frame));\n          noise = mix(noise, nFrame, smoothstep(0.0, .5, u_footer));\n\n    float mask = noise + (frameMask + image.a) * 2.6;\n    #if __VERSION__ == 300\n      float delta = fwidth(mask) * 1.24;\n      finalMask = smoothstep(.5, .5 + delta, mask);\n    #else\n      finalMask = smoothstep(0.5, 0.55, mask);\n    #endif\n\n    // fade content\n    float fade = mix(0.0, 1.0, smoothstep(0.5, .95, u_frame));\n    float invertedMaskWithFadedContent = fade + finalMask;\n\n    gl_FragColor = vec4(u_color, invertedMaskWithFadedContent);\n}\n\n";