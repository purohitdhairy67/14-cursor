export default "#define GLSLIFY 1\nfloat circle(in vec2 _st, in float _radius, in float blurriness){\n  vec2 dist = _st;\n  return 1.-smoothstep(_radius-(_radius*blurriness), _radius+(_radius*blurriness), dot(dist,dist)*4.0);\n}\n\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n// with four individual corner sizes\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nuniform vec3 u_color;\nuniform vec2 u_mouse;\nuniform vec2 u_mouse2;\nuniform vec2 u_mouse3;\nuniform vec2 u_mouse4;\nuniform vec2 u_mouse5;\nuniform float u_pixelRatio;\nuniform vec2 u_res;\nuniform float u_scale;\nuniform float u_alpha;\nuniform float u_fill;\nuniform float u_cursorSize;\n\nvec2 getMouse(vec2 u_m) {\n  float ratio = u_res.y / u_res.x;\n  vec2 mouse = u_m * -0.5;\n  mouse.y *= ratio; // adjust to screen aspect ratio\n  return mouse;\n}\n\nvoid main() {\n  // Get pixel coordinate\n  vec2 res = u_res * u_pixelRatio;\n  float ratio = u_res.y / u_res.x;\n\n  // calculate this fragments position on the screen as [-0.5 to 0.5]\n  vec2 pos = (gl_FragCoord.xy) / res.xy - vec2(0.5);\n  vec2 st = vec2(pos.xy);\n  st.y *= ratio; // adjust to screen aspect ratio\n\n  // We readjust the mouse coordinates\n  vec2 mouse1 = getMouse(u_mouse);\n  vec2 mouse2 = getMouse(u_mouse2);\n  vec2 mouse3 = getMouse(u_mouse3);\n  vec2 mouse4 = getMouse(u_mouse4);\n  vec2 mouse5 = getMouse(u_mouse5);\n\n  // size relative to viewport-ish\n  float size = u_cursorSize / u_res.x / u_res.y * u_scale ;\n\n  // create circles with blur - `circle(position, size, blur)`\n  float fill = 2.6; // add some fill in the middle before blurring\n  float c1 = circle(st + mouse1, size, 100.0) * fill;\n  float c2 = circle(st + mouse2, size, 100.0) * fill;\n  float c3 = circle(st + mouse3, size, 100.0) * fill;\n  float c4 = circle(st + mouse4, size, 100.0) * fill;\n  float c5 = circle(st + mouse5, size, 100.0) * fill;\n\n  // sharpen the blur to melt circles together\n  float mask = c1 + c2 + c3 + c4 + c5;\n\n  #if __VERSION__ == 300\n    float antialias = fwidth(mask);\n  #else\n    float antialias = 0.17;\n  #endif\n\n  float stroke = 0.12778*u_pixelRatio; // size of stroke in relation to size\n  float largeMask = smoothstep(0.5 - antialias, 0.5, mask);\n  float smallMask = smoothstep(0.5 + stroke, 0.5 + stroke + antialias, mask);\n\n  // slice out small circle from the large one\n  float alpha = largeMask - smallMask * u_fill;\n\n  // discard fragment if alpha is low enough\n  if ( mask < 0.0001 ) discard;\n\n  // final color\n  gl_FragColor = vec4(u_color, mask * alpha * u_alpha);\n}\n";
